{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This is a documentation of all OTCamera modules and configuration variables. OTCamera is part of the OpenTrafficCam project and is used to record videos of traffic over several hours or even days. On the left side you can see the main module record along with the config and status module, which contain variables used across the entire code. It is build completly automatically using: MkDocs and mkdocstrings and Material for MkDocs theme. To work on the docs run the following command to get a live updating server. You have to run it on the OTCamera dev pi . python mkdocs serve The site will be publicly served as stativ site on github pages. python -m mkdocs gh-deploy This command will build the current site and push it to the OTCamera repository (branch: gh-pages ).","title":"Home"},{"location":"#home","text":"This is a documentation of all OTCamera modules and configuration variables. OTCamera is part of the OpenTrafficCam project and is used to record videos of traffic over several hours or even days. On the left side you can see the main module record along with the config and status module, which contain variables used across the entire code. It is build completly automatically using: MkDocs and mkdocstrings and Material for MkDocs theme. To work on the docs run the following command to get a live updating server. You have to run it on the OTCamera dev pi . python mkdocs serve The site will be publicly served as stativ site on github pages. python -m mkdocs gh-deploy This command will build the current site and push it to the OTCamera repository (branch: gh-pages ).","title":"Home"},{"location":"config/","text":"config.py OTCamera config variables. All the configuration of OTCamera is done here. DEBUG Turn debug mode on to get addition log entries. ENDHOUR Hour of day when to end recording. INTERVAL Interval length in minutes before video splits. MINFREESPACE free space in GB on sd card before old videos get deleted. N_INTERVALS Number of full intervals to record (0=infinit). PREFIX prefix for videoname and annotation. PREVIEW_INTERVAL Interval between two preview images in seconds. PREVIEWPATH path to save preview. STARTHOUR Hour of day when to start recording. VIDEOPATH path to safe videofiles.","title":"config.py"},{"location":"config/#configpy","text":"","title":"config.py"},{"location":"config/#config","text":"OTCamera config variables. All the configuration of OTCamera is done here.","title":"config"},{"location":"config/#config.DEBUG","text":"Turn debug mode on to get addition log entries.","title":"DEBUG"},{"location":"config/#config.ENDHOUR","text":"Hour of day when to end recording.","title":"ENDHOUR"},{"location":"config/#config.INTERVAL","text":"Interval length in minutes before video splits.","title":"INTERVAL"},{"location":"config/#config.MINFREESPACE","text":"free space in GB on sd card before old videos get deleted.","title":"MINFREESPACE"},{"location":"config/#config.N_INTERVALS","text":"Number of full intervals to record (0=infinit).","title":"N_INTERVALS"},{"location":"config/#config.PREFIX","text":"prefix for videoname and annotation.","title":"PREFIX"},{"location":"config/#config.PREVIEW_INTERVAL","text":"Interval between two preview images in seconds.","title":"PREVIEW_INTERVAL"},{"location":"config/#config.PREVIEWPATH","text":"path to save preview.","title":"PREVIEWPATH"},{"location":"config/#config.STARTHOUR","text":"Hour of day when to start recording.","title":"STARTHOUR"},{"location":"config/#config.VIDEOPATH","text":"path to safe videofiles.","title":"VIDEOPATH"},{"location":"hardware/","text":"/hardware buttons OTCamera helper to interact with hardware buttons. Initializes hardware buttons using gpiozero if configured in config.py. Button callbacks are calling functions in rpi helper its_record_time () Is it time to record or not? Determines if the current hour is an hour after start hour and before end hour configured in config.py as long as the hour button is not pressed. If pressed it's always recording time. Returns: Type Description bool True if it is recording time Source code in hardware/buttons.py def its_record_time (): \"\"\"Is it time to record or not? Determines if the current hour is an hour after start hour and before end hour configured in config.py as long as the hour button is not pressed. If pressed it's always recording time. Returns: bool: True if it is recording time \"\"\" current_hour = dt . now () . hour record_time = ( ( hour . is_pressed ) or ( current_hour >= config . STARTHOUR and current_hour < config . ENDHOUR ) ) and ( not status . SHUTDOWNACTIVE ) return record_time camera OTCamera helper to handle picamera interaction. Used to start, split and stop recording. preview () Capture a preview image. Captures a new preview image, if the current second matches the preview interval configured in config.py and the Wifi AP is turned on (otherwise, a preview would be useless). Source code in hardware/camera.py def preview (): \"\"\"Capture a preview image. Captures a new preview image, if the current second matches the preview interval configured in config.py and the Wifi AP is turned on (otherwise, a preview would be useless). \"\"\" current_second = dt . now () . second offset = config . PREVIEW_INTERVAL - 1 preview_second = ( current_second % config . PREVIEW_INTERVAL ) == offset if preview_second and status . preview_on () and status . new_preview : log . write ( \"new preview\" , level = \"debug\" ) _capture () status . new_preview = False elif not ( preview_second or status . new_preview ): log . write ( \"reset new preview\" , level = \"debug\" ) status . new_preview = True split_if_interval_ends () Splits the videofile if the configured intervals ends. An Interval is configured in config.py. If the current minute matches the interval length, the video file is split and a new file begins. Counts the full intervals already recorded. If the maximum number of intervals, configured in config.py is reached, recording stops by breaking the loop in record.py. Source code in hardware/camera.py def split_if_interval_ends (): \"\"\"Splits the videofile if the configured intervals ends. An Interval is configured in config.py. If the current minute matches the interval length, the video file is split and a new file begins. Counts the full intervals already recorded. If the maximum number of intervals, configured in config.py is reached, recording stops by breaking the loop in record.py. \"\"\" if _new_interval (): log . write ( \"new interval\" , level = \"debug\" ) _split () status . interval_finished = False status . current_interval += 1 if config . N_INTERVALS > 0 : status . more_intervals = status . current_interval < config . N_INTERVALS if not status . more_intervals : log . write ( \"last interval\" , level = \"debug\" ) elif _after_new_interval (): status . interval_finished = True log . write ( \"reset new interval\" , level = \"debug\" ) _wait_recording ( 0.5 ) start_recording () Start a recording a video. If picam isn't already recording: - Deletes old files, until enough free space is available. - Starts a new recording on picam, using the config.py. - Waits 2 seconds and caputres a preview image. - Turns on the record LED (if attached). Source code in hardware/camera.py def start_recording (): \"\"\"Start a recording a video. If picam isn't already recording: - Deletes old files, until enough free space is available. - Starts a new recording on picam, using the config.py. - Waits 2 seconds and caputres a preview image. - Turns on the record LED (if attached). \"\"\" # TODO: exception handling if not picam . recording : delete_old_files () picam . annotate_text = name . annotate () picam . start_recording ( output = name . video (), format = config . FORMAT , resize = config . RESIZE , profile = config . PROFILE , level = config . LEVEL , bitrate = config . BITRATE , quality = config . QUALITY , ) log . write ( \"started recording\" ) _wait_recording ( 2 ) _capture () leds . rec_on () else : pass stop_recording () Stops the video recording. If the picamera is recording, the recording is stopped. Additionally, the record LED ist switched of (if configured). Source code in hardware/camera.py def stop_recording (): \"\"\"Stops the video recording. If the picamera is recording, the recording is stopped. Additionally, the record LED ist switched of (if configured). \"\"\" if picam . recording : picam . stop_recording () leds . rec_off () log . write ( \"recorded {n} videos\" . format ( n = status . current_interval )) log . write ( \"stopped recording\" ) leds OTCamera LED interaction helper. If LEDs are configured in config.py this modules handels all the interaction (on, off, blinking) of the LEDs. off () Turn all LEDs off. Source code in hardware/leds.py def off (): \"\"\"Turn all LEDs off.\"\"\" if config . USE_LED : power . on () wifi . on () rec . on () else : pass power_on () Blink power LED infinite. Source code in hardware/leds.py def power_on (): \"\"\"Blink power LED infinite.\"\"\" if config . USE_LED : power . blink ( on_time = 0.1 , off_time = 0 , n = 1 , background = True ) else : pass rec_off () Pulse record LED 4 times and switch it off. Source code in hardware/leds.py def rec_off (): \"\"\"Pulse record LED 4 times and switch it off.\"\"\" if config . USE_LED : rec . off () rec . pulse ( fade_in_time = 0.25 , fade_out_time = 0.25 , n = 4 , background = True ) else : pass rec_on () Blink record LED infinite. Source code in hardware/leds.py def rec_on (): \"\"\"Blink record LED infinite.\"\"\" if config . USE_LED : rec . blink ( on_time = 0.1 , off_time = 4.9 , n = None , background = True ) else : pass","title":"/hardware"},{"location":"hardware/#hardware_1","text":"","title":"/hardware"},{"location":"hardware/#hardware","text":"","title":"hardware"},{"location":"hardware/#hardware.buttons","text":"OTCamera helper to interact with hardware buttons. Initializes hardware buttons using gpiozero if configured in config.py. Button callbacks are calling functions in rpi helper","title":"buttons"},{"location":"hardware/#hardware.buttons.its_record_time","text":"Is it time to record or not? Determines if the current hour is an hour after start hour and before end hour configured in config.py as long as the hour button is not pressed. If pressed it's always recording time. Returns: Type Description bool True if it is recording time Source code in hardware/buttons.py def its_record_time (): \"\"\"Is it time to record or not? Determines if the current hour is an hour after start hour and before end hour configured in config.py as long as the hour button is not pressed. If pressed it's always recording time. Returns: bool: True if it is recording time \"\"\" current_hour = dt . now () . hour record_time = ( ( hour . is_pressed ) or ( current_hour >= config . STARTHOUR and current_hour < config . ENDHOUR ) ) and ( not status . SHUTDOWNACTIVE ) return record_time","title":"its_record_time()"},{"location":"hardware/#hardware.camera","text":"OTCamera helper to handle picamera interaction. Used to start, split and stop recording.","title":"camera"},{"location":"hardware/#hardware.camera.preview","text":"Capture a preview image. Captures a new preview image, if the current second matches the preview interval configured in config.py and the Wifi AP is turned on (otherwise, a preview would be useless). Source code in hardware/camera.py def preview (): \"\"\"Capture a preview image. Captures a new preview image, if the current second matches the preview interval configured in config.py and the Wifi AP is turned on (otherwise, a preview would be useless). \"\"\" current_second = dt . now () . second offset = config . PREVIEW_INTERVAL - 1 preview_second = ( current_second % config . PREVIEW_INTERVAL ) == offset if preview_second and status . preview_on () and status . new_preview : log . write ( \"new preview\" , level = \"debug\" ) _capture () status . new_preview = False elif not ( preview_second or status . new_preview ): log . write ( \"reset new preview\" , level = \"debug\" ) status . new_preview = True","title":"preview()"},{"location":"hardware/#hardware.camera.split_if_interval_ends","text":"Splits the videofile if the configured intervals ends. An Interval is configured in config.py. If the current minute matches the interval length, the video file is split and a new file begins. Counts the full intervals already recorded. If the maximum number of intervals, configured in config.py is reached, recording stops by breaking the loop in record.py. Source code in hardware/camera.py def split_if_interval_ends (): \"\"\"Splits the videofile if the configured intervals ends. An Interval is configured in config.py. If the current minute matches the interval length, the video file is split and a new file begins. Counts the full intervals already recorded. If the maximum number of intervals, configured in config.py is reached, recording stops by breaking the loop in record.py. \"\"\" if _new_interval (): log . write ( \"new interval\" , level = \"debug\" ) _split () status . interval_finished = False status . current_interval += 1 if config . N_INTERVALS > 0 : status . more_intervals = status . current_interval < config . N_INTERVALS if not status . more_intervals : log . write ( \"last interval\" , level = \"debug\" ) elif _after_new_interval (): status . interval_finished = True log . write ( \"reset new interval\" , level = \"debug\" ) _wait_recording ( 0.5 )","title":"split_if_interval_ends()"},{"location":"hardware/#hardware.camera.start_recording","text":"Start a recording a video. If picam isn't already recording: - Deletes old files, until enough free space is available. - Starts a new recording on picam, using the config.py. - Waits 2 seconds and caputres a preview image. - Turns on the record LED (if attached). Source code in hardware/camera.py def start_recording (): \"\"\"Start a recording a video. If picam isn't already recording: - Deletes old files, until enough free space is available. - Starts a new recording on picam, using the config.py. - Waits 2 seconds and caputres a preview image. - Turns on the record LED (if attached). \"\"\" # TODO: exception handling if not picam . recording : delete_old_files () picam . annotate_text = name . annotate () picam . start_recording ( output = name . video (), format = config . FORMAT , resize = config . RESIZE , profile = config . PROFILE , level = config . LEVEL , bitrate = config . BITRATE , quality = config . QUALITY , ) log . write ( \"started recording\" ) _wait_recording ( 2 ) _capture () leds . rec_on () else : pass","title":"start_recording()"},{"location":"hardware/#hardware.camera.stop_recording","text":"Stops the video recording. If the picamera is recording, the recording is stopped. Additionally, the record LED ist switched of (if configured). Source code in hardware/camera.py def stop_recording (): \"\"\"Stops the video recording. If the picamera is recording, the recording is stopped. Additionally, the record LED ist switched of (if configured). \"\"\" if picam . recording : picam . stop_recording () leds . rec_off () log . write ( \"recorded {n} videos\" . format ( n = status . current_interval )) log . write ( \"stopped recording\" )","title":"stop_recording()"},{"location":"hardware/#hardware.leds","text":"OTCamera LED interaction helper. If LEDs are configured in config.py this modules handels all the interaction (on, off, blinking) of the LEDs.","title":"leds"},{"location":"hardware/#hardware.leds.off","text":"Turn all LEDs off. Source code in hardware/leds.py def off (): \"\"\"Turn all LEDs off.\"\"\" if config . USE_LED : power . on () wifi . on () rec . on () else : pass","title":"off()"},{"location":"hardware/#hardware.leds.power_on","text":"Blink power LED infinite. Source code in hardware/leds.py def power_on (): \"\"\"Blink power LED infinite.\"\"\" if config . USE_LED : power . blink ( on_time = 0.1 , off_time = 0 , n = 1 , background = True ) else : pass","title":"power_on()"},{"location":"hardware/#hardware.leds.rec_off","text":"Pulse record LED 4 times and switch it off. Source code in hardware/leds.py def rec_off (): \"\"\"Pulse record LED 4 times and switch it off.\"\"\" if config . USE_LED : rec . off () rec . pulse ( fade_in_time = 0.25 , fade_out_time = 0.25 , n = 4 , background = True ) else : pass","title":"rec_off()"},{"location":"hardware/#hardware.leds.rec_on","text":"Blink record LED infinite. Source code in hardware/leds.py def rec_on (): \"\"\"Blink record LED infinite.\"\"\" if config . USE_LED : rec . blink ( on_time = 0.1 , off_time = 4.9 , n = None , background = True ) else : pass","title":"rec_on()"},{"location":"helpers/","text":"/helpers filesystem OTCamera helper fo filesystem stuff. Check if enough filespace is available and delete old files until it's enough. delete_old_files () Delete old files until enough space available. Checks if enough space (config.MINFREESPACE) is a availabe to save video files. If not, deletes the oldest files in config.VIDEOPATH one after another until enough space is available on disk. Source code in helpers/filesystem.py def delete_old_files (): \"\"\"Delete old files until enough space available. Checks if enough space (config.MINFREESPACE) is a availabe to save video files. If not, deletes the oldest files in config.VIDEOPATH one after another until enough space is available on disk. \"\"\" log . write ( \"delete old file\" , level = \"debug\" ) minfreespace = config . MINFREESPACE * 1024 * 1024 * 1024 free_space = psutil . disk_usage ( config . VIDEOPATH ) . free enough_space = free_space > minfreespace log . write ( \"free space: {fs} \" . format ( fs = free_space ), level = \"DEBUG\" ) log . write ( \"min space: {ms} \" . format ( ms = minfreespace ), level = \"DEBUG\" ) while not enough_space : oldest_video = min ( os . listdir ( config . VIDEOPATH ), key = os . path . getctime ) os . remove ( config . VIDEOPATH + oldest_video ) log . breakline () log . write ( \"Deleted \" + oldest_video ) free_space = psutil . disk_usage ( \"/\" ) . free log . write ( \"free space: {fs} \" . format ( fs = free_space ), level = \"debug\" ) enough_space = free_space > minfreespace log OTCamera helper for logging. Open a logfile, based on the name.log and write a message to it. Also prints all messages. Use log.write(msg) to write any message, log.breakline() to write a single line of # or log.otc() to log and print a OpenTrafficCam logo. breakline ( reboot = True ) Write a breakline. Write a breakline containing several # to the logfile. Parameters: Name Type Description Default reboot bool Perform reboot if logging fails. Defaults to True. True Source code in helpers/log.py def breakline ( reboot = True ): \"\"\"Write a breakline. Write a breakline containing several # to the logfile. Args: reboot (bool, optional): Perform reboot if logging fails. Defaults to True. \"\"\" msg = \" \\n ############################ \\n \" _write ( msg ) closefile () Flush and close the logfile. Source code in helpers/log.py def closefile (): \"\"\"Flush and close the logfile.\"\"\" logfile . flush () logfile . close () otc () Generate a ASCII logo and write it to the logfile. Source code in helpers/log.py def otc (): \"\"\"Generate a ASCII logo and write it to the logfile.\"\"\" otclogo = text2art ( \"OpenTrafficCam\" ) _write ( otclogo ) otcamera = text2art ( \"OTCamera\" ) _write ( otcamera ) write ( msg , level = 'info' , reboot = True ) Write any message to logfile. Takes a message, adds date and time and writes it to a logfile (name.log). Parameters: Name Type Description Default msg str Message to be written. required level str either \"debug\", \"info\", \"warning\", \"error\", \"exception\" 'info' reboot bool Perform reboot if logging fails. Defaults to True. True Source code in helpers/log.py def write ( msg , level = \"info\" , reboot = True ): \"\"\"Write any message to logfile. Takes a message, adds date and time and writes it to a logfile (name.log). Args: msg (str): Message to be written. level (str): either \"debug\", \"info\", \"warning\", \"error\", \"exception\" reboot (bool, optional): Perform reboot if logging fails. Defaults to True. \"\"\" level = level . upper () if level == \"DEBUG\" : if not DEBUG : return msg = \" {t} {level} : {msg} \" . format ( t = name . _current_dt (), level = level . upper (), msg = msg ) _write ( msg , reboot ) name OTCamera helpers for (file)names. Generates strings for use in different modules. For example the logfilename or videofilename or the string to annotate the video. annotate () String to annotate video. Text to be added as annotation to video footage. Contains a Prefix and current datetime. Returns: Type Description str annotation text Source code in helpers/name.py def annotate (): \"\"\"String to annotate video. Text to be added as annotation to video footage. Contains a Prefix and current datetime. Returns: str: annotation text \"\"\" time_str = dt . now () . strftime ( config . PREFIX + \" %d .%m.%Y %H:%M:%S\" ) return time_str log () Filename of logfile. Path incl. filename where logfile is saved. Returns: Type Description str filename for log Source code in helpers/name.py def log (): \"\"\"Filename of logfile. Path incl. filename where logfile is saved. Returns: str: filename for log \"\"\" filename = config . VIDEOPATH + config . PREFIX + \"_\" + _current_dt () + \".log\" return filename preview () Filename for preview image. Path incl. filename where preview file is saved. Returns: Type Description str filename for preview Source code in helpers/name.py def preview (): \"\"\"Filename for preview image. Path incl. filename where preview file is saved. Returns: str: filename for preview \"\"\" return config . PREVIEWPATH video () Filename of Video. Path incl. filename where videos are saved to, based on hostname and current date and time. Returns: Type Description str filename for video Source code in helpers/name.py def video (): \"\"\"Filename of Video. Path incl. filename where videos are saved to, based on hostname and current date and time. Returns: str: filename for video \"\"\" filename = config . VIDEOPATH + config . PREFIX + \"_\" + _current_dt () + \".h264\" return filename rpi OTCamera helpers to control the RPi interfaces. Contains all functions to control the Raspberry Pi itself. lowbattery () Shutdown if battery is low. Shuts down the Raspberry Pi if called and writes a message to the logfile. Source code in helpers/rpi.py def lowbattery (): \"\"\"Shutdown if battery is low. Shuts down the Raspberry Pi if called and writes a message to the logfile. \"\"\" log . write ( \"Low Battery\" , False ) camera . stop_recording () status . shutdownactive = True log . breakline () log . write ( \"Shutdown\" , False ) log . breakline () log . closefile () call ( \"sudo shutdown -h -t 0\" , shell = True ) reboot () Reboot the Raspberry Pi. Reboots the Raspberry Pi if any expection is raised. Tries to close the camera object and writes to logfile. Source code in helpers/rpi.py def reboot (): \"\"\"Reboot the Raspberry Pi. Reboots the Raspberry Pi if any expection is raised. Tries to close the camera object and writes to logfile. \"\"\" status . shutdownactive = True status . noblink = True leds . power . blink ( on_time = 0.1 , off_time = 0.1 , fade_in_time = 0 , fade_out_time = 0 , n = None , background = True , ) log . write ( \"Reboot\" , False ) log . breakline () log . closefile () camera . stop_recording () if not config . DEBUG : call ( \"sudo reboot\" , shell = True ) shutdown () Shutdown the Raspberry Pi. Shuts down the Raspberry Pi if the power button is still pressed after blink ends (2 seconds). Tries to stop and close the camera object. Writes messages to the logfile. Source code in helpers/rpi.py def shutdown (): \"\"\"Shutdown the Raspberry Pi. Shuts down the Raspberry Pi if the power button is still pressed after blink ends (2 seconds). Tries to stop and close the camera object. Writes messages to the logfile. \"\"\" log . write ( \"Shutdown by button in 2s\" , False ) status . noblink = True leds . power . blink ( on_time = 0.5 , off_time = 0.5 , fade_in_time = 0 , fade_out_time = 0 , n = 8 , background = False , ) leds . power . on () leds . wifi . off () if buttons . power . is_pressed : status . noblink = False log . write ( \"Shutdown cancelled\" , False ) return else : status . shutdownactive = True camera . stop_recording () log . breakline () log . write ( \"Shutdown\" , False ) log . breakline () log . closefile () call ( \"sudo shutdown -h -t 0\" , shell = True ) wifi () Switches the status of the Wifi-AP. If status.wifiapon is False, a script is started to turn the AP on. If status.wifiapon is True, it stops the AP after config.WIFIDELAY seconds. Uses a LED to signalize the status. Source code in helpers/rpi.py def wifi (): \"\"\"Switches the status of the Wifi-AP. If status.wifiapon is False, a script is started to turn the AP on. If status.wifiapon is True, it stops the AP after config.WIFIDELAY seconds. Uses a LED to signalize the status. \"\"\" log . write ( \"Wifiswitch\" ) if buttons . wifi . is_pressed and not status . wifiapon : log . write ( \"Turn WifiAP on\" ) call ( \"sudo /bin/bash /usr/local/bin/wifistart\" , shell = True ) log . write ( \"WifiAP on\" ) leds . power . pulse ( fade_in_time = 0.25 , fade_out_time = 0.25 , n = 2 , background = True ) leds . wifi . blink ( on_time = 0.1 , off_time = 4.9 , n = None , background = True ) status . wifiapon = True elif not buttons . wifi . is_pressed and status . wifiapon : leds . power . pulse ( fade_in_time = 0.25 , fade_out_time = 0.25 , n = 2 , background = True ) if not config . DEBUG : sleep ( config . WIFIDELAY ) if not buttons . wifi . is_pressed and status . wifiapon : log . write ( \"Turn WifiAP OFF\" ) call ( \"sudo systemctl stop hostapd.service\" , shell = True ) call ( \"sudo systemctl stop dnsmasq.service\" , shell = True ) call ( \"sudo ifconfig uap0 down\" , shell = True ) log . write ( \"WifiAP OFF\" ) leds . wifi . off () status . wifiapon = False","title":"/helpers"},{"location":"helpers/#helpers_1","text":"","title":"/helpers"},{"location":"helpers/#helpers","text":"","title":"helpers"},{"location":"helpers/#helpers.filesystem","text":"OTCamera helper fo filesystem stuff. Check if enough filespace is available and delete old files until it's enough.","title":"filesystem"},{"location":"helpers/#helpers.filesystem.delete_old_files","text":"Delete old files until enough space available. Checks if enough space (config.MINFREESPACE) is a availabe to save video files. If not, deletes the oldest files in config.VIDEOPATH one after another until enough space is available on disk. Source code in helpers/filesystem.py def delete_old_files (): \"\"\"Delete old files until enough space available. Checks if enough space (config.MINFREESPACE) is a availabe to save video files. If not, deletes the oldest files in config.VIDEOPATH one after another until enough space is available on disk. \"\"\" log . write ( \"delete old file\" , level = \"debug\" ) minfreespace = config . MINFREESPACE * 1024 * 1024 * 1024 free_space = psutil . disk_usage ( config . VIDEOPATH ) . free enough_space = free_space > minfreespace log . write ( \"free space: {fs} \" . format ( fs = free_space ), level = \"DEBUG\" ) log . write ( \"min space: {ms} \" . format ( ms = minfreespace ), level = \"DEBUG\" ) while not enough_space : oldest_video = min ( os . listdir ( config . VIDEOPATH ), key = os . path . getctime ) os . remove ( config . VIDEOPATH + oldest_video ) log . breakline () log . write ( \"Deleted \" + oldest_video ) free_space = psutil . disk_usage ( \"/\" ) . free log . write ( \"free space: {fs} \" . format ( fs = free_space ), level = \"debug\" ) enough_space = free_space > minfreespace","title":"delete_old_files()"},{"location":"helpers/#helpers.log","text":"OTCamera helper for logging. Open a logfile, based on the name.log and write a message to it. Also prints all messages. Use log.write(msg) to write any message, log.breakline() to write a single line of # or log.otc() to log and print a OpenTrafficCam logo.","title":"log"},{"location":"helpers/#helpers.log.breakline","text":"Write a breakline. Write a breakline containing several # to the logfile. Parameters: Name Type Description Default reboot bool Perform reboot if logging fails. Defaults to True. True Source code in helpers/log.py def breakline ( reboot = True ): \"\"\"Write a breakline. Write a breakline containing several # to the logfile. Args: reboot (bool, optional): Perform reboot if logging fails. Defaults to True. \"\"\" msg = \" \\n ############################ \\n \" _write ( msg )","title":"breakline()"},{"location":"helpers/#helpers.log.closefile","text":"Flush and close the logfile. Source code in helpers/log.py def closefile (): \"\"\"Flush and close the logfile.\"\"\" logfile . flush () logfile . close ()","title":"closefile()"},{"location":"helpers/#helpers.log.otc","text":"Generate a ASCII logo and write it to the logfile. Source code in helpers/log.py def otc (): \"\"\"Generate a ASCII logo and write it to the logfile.\"\"\" otclogo = text2art ( \"OpenTrafficCam\" ) _write ( otclogo ) otcamera = text2art ( \"OTCamera\" ) _write ( otcamera )","title":"otc()"},{"location":"helpers/#helpers.log.write","text":"Write any message to logfile. Takes a message, adds date and time and writes it to a logfile (name.log). Parameters: Name Type Description Default msg str Message to be written. required level str either \"debug\", \"info\", \"warning\", \"error\", \"exception\" 'info' reboot bool Perform reboot if logging fails. Defaults to True. True Source code in helpers/log.py def write ( msg , level = \"info\" , reboot = True ): \"\"\"Write any message to logfile. Takes a message, adds date and time and writes it to a logfile (name.log). Args: msg (str): Message to be written. level (str): either \"debug\", \"info\", \"warning\", \"error\", \"exception\" reboot (bool, optional): Perform reboot if logging fails. Defaults to True. \"\"\" level = level . upper () if level == \"DEBUG\" : if not DEBUG : return msg = \" {t} {level} : {msg} \" . format ( t = name . _current_dt (), level = level . upper (), msg = msg ) _write ( msg , reboot )","title":"write()"},{"location":"helpers/#helpers.name","text":"OTCamera helpers for (file)names. Generates strings for use in different modules. For example the logfilename or videofilename or the string to annotate the video.","title":"name"},{"location":"helpers/#helpers.name.annotate","text":"String to annotate video. Text to be added as annotation to video footage. Contains a Prefix and current datetime. Returns: Type Description str annotation text Source code in helpers/name.py def annotate (): \"\"\"String to annotate video. Text to be added as annotation to video footage. Contains a Prefix and current datetime. Returns: str: annotation text \"\"\" time_str = dt . now () . strftime ( config . PREFIX + \" %d .%m.%Y %H:%M:%S\" ) return time_str","title":"annotate()"},{"location":"helpers/#helpers.name.log","text":"Filename of logfile. Path incl. filename where logfile is saved. Returns: Type Description str filename for log Source code in helpers/name.py def log (): \"\"\"Filename of logfile. Path incl. filename where logfile is saved. Returns: str: filename for log \"\"\" filename = config . VIDEOPATH + config . PREFIX + \"_\" + _current_dt () + \".log\" return filename","title":"log()"},{"location":"helpers/#helpers.name.preview","text":"Filename for preview image. Path incl. filename where preview file is saved. Returns: Type Description str filename for preview Source code in helpers/name.py def preview (): \"\"\"Filename for preview image. Path incl. filename where preview file is saved. Returns: str: filename for preview \"\"\" return config . PREVIEWPATH","title":"preview()"},{"location":"helpers/#helpers.name.video","text":"Filename of Video. Path incl. filename where videos are saved to, based on hostname and current date and time. Returns: Type Description str filename for video Source code in helpers/name.py def video (): \"\"\"Filename of Video. Path incl. filename where videos are saved to, based on hostname and current date and time. Returns: str: filename for video \"\"\" filename = config . VIDEOPATH + config . PREFIX + \"_\" + _current_dt () + \".h264\" return filename","title":"video()"},{"location":"helpers/#helpers.rpi","text":"OTCamera helpers to control the RPi interfaces. Contains all functions to control the Raspberry Pi itself.","title":"rpi"},{"location":"helpers/#helpers.rpi.lowbattery","text":"Shutdown if battery is low. Shuts down the Raspberry Pi if called and writes a message to the logfile. Source code in helpers/rpi.py def lowbattery (): \"\"\"Shutdown if battery is low. Shuts down the Raspberry Pi if called and writes a message to the logfile. \"\"\" log . write ( \"Low Battery\" , False ) camera . stop_recording () status . shutdownactive = True log . breakline () log . write ( \"Shutdown\" , False ) log . breakline () log . closefile () call ( \"sudo shutdown -h -t 0\" , shell = True )","title":"lowbattery()"},{"location":"helpers/#helpers.rpi.reboot","text":"Reboot the Raspberry Pi. Reboots the Raspberry Pi if any expection is raised. Tries to close the camera object and writes to logfile. Source code in helpers/rpi.py def reboot (): \"\"\"Reboot the Raspberry Pi. Reboots the Raspberry Pi if any expection is raised. Tries to close the camera object and writes to logfile. \"\"\" status . shutdownactive = True status . noblink = True leds . power . blink ( on_time = 0.1 , off_time = 0.1 , fade_in_time = 0 , fade_out_time = 0 , n = None , background = True , ) log . write ( \"Reboot\" , False ) log . breakline () log . closefile () camera . stop_recording () if not config . DEBUG : call ( \"sudo reboot\" , shell = True )","title":"reboot()"},{"location":"helpers/#helpers.rpi.shutdown","text":"Shutdown the Raspberry Pi. Shuts down the Raspberry Pi if the power button is still pressed after blink ends (2 seconds). Tries to stop and close the camera object. Writes messages to the logfile. Source code in helpers/rpi.py def shutdown (): \"\"\"Shutdown the Raspberry Pi. Shuts down the Raspberry Pi if the power button is still pressed after blink ends (2 seconds). Tries to stop and close the camera object. Writes messages to the logfile. \"\"\" log . write ( \"Shutdown by button in 2s\" , False ) status . noblink = True leds . power . blink ( on_time = 0.5 , off_time = 0.5 , fade_in_time = 0 , fade_out_time = 0 , n = 8 , background = False , ) leds . power . on () leds . wifi . off () if buttons . power . is_pressed : status . noblink = False log . write ( \"Shutdown cancelled\" , False ) return else : status . shutdownactive = True camera . stop_recording () log . breakline () log . write ( \"Shutdown\" , False ) log . breakline () log . closefile () call ( \"sudo shutdown -h -t 0\" , shell = True )","title":"shutdown()"},{"location":"helpers/#helpers.rpi.wifi","text":"Switches the status of the Wifi-AP. If status.wifiapon is False, a script is started to turn the AP on. If status.wifiapon is True, it stops the AP after config.WIFIDELAY seconds. Uses a LED to signalize the status. Source code in helpers/rpi.py def wifi (): \"\"\"Switches the status of the Wifi-AP. If status.wifiapon is False, a script is started to turn the AP on. If status.wifiapon is True, it stops the AP after config.WIFIDELAY seconds. Uses a LED to signalize the status. \"\"\" log . write ( \"Wifiswitch\" ) if buttons . wifi . is_pressed and not status . wifiapon : log . write ( \"Turn WifiAP on\" ) call ( \"sudo /bin/bash /usr/local/bin/wifistart\" , shell = True ) log . write ( \"WifiAP on\" ) leds . power . pulse ( fade_in_time = 0.25 , fade_out_time = 0.25 , n = 2 , background = True ) leds . wifi . blink ( on_time = 0.1 , off_time = 4.9 , n = None , background = True ) status . wifiapon = True elif not buttons . wifi . is_pressed and status . wifiapon : leds . power . pulse ( fade_in_time = 0.25 , fade_out_time = 0.25 , n = 2 , background = True ) if not config . DEBUG : sleep ( config . WIFIDELAY ) if not buttons . wifi . is_pressed and status . wifiapon : log . write ( \"Turn WifiAP OFF\" ) call ( \"sudo systemctl stop hostapd.service\" , shell = True ) call ( \"sudo systemctl stop dnsmasq.service\" , shell = True ) call ( \"sudo ifconfig uap0 down\" , shell = True ) log . write ( \"WifiAP OFF\" ) leds . wifi . off () status . wifiapon = False","title":"wifi()"},{"location":"record/","text":"record.py OTCamera main module to record videos. This module can be used to record either some intervals or continuously. It is configured by config.py. init () Initializes the LEDs and Wifi AP. Source code in OTCamera/record.py def init (): \"\"\"Initializes the LEDs and Wifi AP.\"\"\" log . breakline () log . write ( \"starting periodic record\" ) leds . power_on () loop () Record and split videos. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. Source code in OTCamera/record.py def loop (): \"\"\"Record and split videos. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. \"\"\" if status . record_time (): camera . start_recording () camera . split_if_interval_ends () camera . preview () else : camera . stop_recording () sleep ( 0.5 ) record () Run init and record loop. Initializes the LEDs ans Wifi AP. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. Stops everthing by keyboard interrupt (Ctrl+C). Source code in OTCamera/record.py def record (): \"\"\"Run init and record loop. Initializes the LEDs ans Wifi AP. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. Stops everthing by keyboard interrupt (Ctrl+C). \"\"\" try : init () while status . more_intervals : loop () log . write ( \"Captured all intervals, stopping\" , level = \"warning\" ) except ( KeyboardInterrupt ): log . write ( \"Keyboard Interrupt, stopping\" , level = \"warning\" ) camera . stop_recording () log . closefile ()","title":"record.py"},{"location":"record/#recordpy","text":"","title":"record.py"},{"location":"record/#record","text":"OTCamera main module to record videos. This module can be used to record either some intervals or continuously. It is configured by config.py.","title":"record"},{"location":"record/#record.init","text":"Initializes the LEDs and Wifi AP. Source code in OTCamera/record.py def init (): \"\"\"Initializes the LEDs and Wifi AP.\"\"\" log . breakline () log . write ( \"starting periodic record\" ) leds . power_on ()","title":"init()"},{"location":"record/#record.loop","text":"Record and split videos. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. Source code in OTCamera/record.py def loop (): \"\"\"Record and split videos. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. \"\"\" if status . record_time (): camera . start_recording () camera . split_if_interval_ends () camera . preview () else : camera . stop_recording () sleep ( 0.5 )","title":"loop()"},{"location":"record/#record.record","text":"Run init and record loop. Initializes the LEDs ans Wifi AP. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. Stops everthing by keyboard interrupt (Ctrl+C). Source code in OTCamera/record.py def record (): \"\"\"Run init and record loop. Initializes the LEDs ans Wifi AP. While it is recording time (see status.py), starts recording videos, splits them every interval (see config.py), captures a new preview image and stops recording after recording time ends. Stops everthing by keyboard interrupt (Ctrl+C). \"\"\" try : init () while status . more_intervals : loop () log . write ( \"Captured all intervals, stopping\" , level = \"warning\" ) except ( KeyboardInterrupt ): log . write ( \"Keyboard Interrupt, stopping\" , level = \"warning\" ) camera . stop_recording () log . closefile ()","title":"record()"},{"location":"status/","text":"status.py OTCamera Status variables and functions. Contains all status variables and functions to be used across multiple modules. preview_on () Checks if a preview image should be captured. Returns True if there are buttons configured and the WifiAP status is True. Returns always True if no buttons configured. Returns: Type Description bool Capture new preview. Source code in OTCamera/status.py def preview_on (): \"\"\"Checks if a preview image should be captured. Returns True if there are buttons configured and the WifiAP status is True. Returns always True if no buttons configured. Returns: bool: Capture new preview. \"\"\" if config . USE_BUTTONS : return wifiapon else : return True record_time () Checks if the current hour is an hour to record. Returns True if the hour of the current time is either after configured start hour and before end hour or hardware button is switched to continuous record. Returns: Type Description bool Time to record or not. Source code in OTCamera/status.py def record_time (): \"\"\"Checks if the current hour is an hour to record. Returns True if the hour of the current time is either after configured start hour and before end hour or hardware button is switched to continuous record. Returns: bool: Time to record or not. \"\"\" current_hour = dt . now () . hour bytime = current_hour >= config . STARTHOUR and current_hour < config . ENDHOUR if config . USE_BUTTONS : bybutton = buttons . hour . is_pressed record = bybutton or bytime else : record = bytime record = record and ( not shutdownactive ) return record","title":"status.py"},{"location":"status/#statuspy","text":"","title":"status.py"},{"location":"status/#status","text":"OTCamera Status variables and functions. Contains all status variables and functions to be used across multiple modules.","title":"status"},{"location":"status/#status.preview_on","text":"Checks if a preview image should be captured. Returns True if there are buttons configured and the WifiAP status is True. Returns always True if no buttons configured. Returns: Type Description bool Capture new preview. Source code in OTCamera/status.py def preview_on (): \"\"\"Checks if a preview image should be captured. Returns True if there are buttons configured and the WifiAP status is True. Returns always True if no buttons configured. Returns: bool: Capture new preview. \"\"\" if config . USE_BUTTONS : return wifiapon else : return True","title":"preview_on()"},{"location":"status/#status.record_time","text":"Checks if the current hour is an hour to record. Returns True if the hour of the current time is either after configured start hour and before end hour or hardware button is switched to continuous record. Returns: Type Description bool Time to record or not. Source code in OTCamera/status.py def record_time (): \"\"\"Checks if the current hour is an hour to record. Returns True if the hour of the current time is either after configured start hour and before end hour or hardware button is switched to continuous record. Returns: bool: Time to record or not. \"\"\" current_hour = dt . now () . hour bytime = current_hour >= config . STARTHOUR and current_hour < config . ENDHOUR if config . USE_BUTTONS : bybutton = buttons . hour . is_pressed record = bybutton or bytime else : record = bytime record = record and ( not shutdownactive ) return record","title":"record_time()"}]}